# Custom MVC

The project **Custom MVC** is PHP open-source web application MVC framework.  

## Installation and requirements

Clone the repository from GitHub or download it as a ZIP file:
     ```
     git clone https://github.com/ManoelViktorovManev/Custom_MVC.git
     ```
   - If you downloaded the ZIP file, extract it to your desired directory.


This project requires **PHP 8** or above to run. Ensure that PHP is installed and accessible from the command line.

Make sure you are having database management system (DBMS) like  **MySQL, MariaDB, PostgreSQL** or others.


## Project structure

```
project-root/
├── config/              # Configurate routes files
│   └── routes.php
│   └── routes.yaml
│
├── controller/          # Directory for user-defined Controllers, each extending the BaseController
│   └── ExampleController.php
│
├── core/                # Core framework logic and base classes (e.g., BaseController, Router, BaseModel)
│   └── BaseController.php
│   └── Router.php
│   └── BaseModel.php
│
├── models/              # Directory for user-defined models (entities), each extending BaseModel
│   └── User.php
│
├── tests/               # Directory for unit and integration tests
│   └── ExampleTest.php
│
├── vendor/              # Composer dependencies (auto-generated by Composer, do not edit manually)
│
├── view/                # Directory for HTML view templates
│   └── layout.html
│   └── home.html
│
├── .env                 # Environment variables (e.g., database URL, timezone)
├── phpunit.xml          # PHPUnit configuration file for running tests
├── composer.json        # Composer configuration file listing dependencies and autoloading settings
└── README.md            # Project documentation
```
### Configuration and Setup

1. **Edit the Configuration File**: Open the `.env` file in the project’s root directory and configure the following values:
   - **`DATABASE_URL`**: Defines the database connection string.
   - **`LOCAL_TIMEZONE`**: Sets the timezone for log entries.

2. **Start the Database**: Ensure your database application is running and accessible based on the DATABASE_URL configuration.

3. **Run the Server**: In the terminal, navigate to your project directory and start the PHP server:
```
php -S localhost:8080
```
Your application should now be accessible at http://localhost:8080.


## Routes
**Routes** in this project are defined using attributes within each method of the Controller classes. Each route attribute specifies the path and parameters for accessing that method, allowing the framework to map URLs to specific controller actions.




There are four main types of routes you can define:
```
#[Route('/path')]                         // Basic route with a fixed path.
#[Route('/user/{id}')]                    // Route with a dynamic parameter, e.g., /user/123.
#[Route('/normal/test', name: 'param')]   // Named route, useful for generating URLs programmatically.
#[Route('/optional/{id?}')]               // Optional parameter, e.g., /optional/ or /optional/123.
```
For older versions of PHP you can use the **config** folder to configurate the **Routes**. There are two ways to configurate the Routes from config files by updating: **routes.php** or **routes.yaml**.

Here are example for boths:
```php
# routes.php
<?php
namespace App\Config;

use App\Core\Router;

return function (Router $routes): void {
    # HOW SHOULD BE CALLED:
    # $routes->add($name_of_route,$url_path)->controller($instance_of_controller_class,$action)
    $routes->add('izwajdane12', '/minus/{param1}/{param2}')
        ->controller(NewPhpRouteImp::class, 'minusNa2Chisla');
};
```
```yaml
# routes.yaml

# How should be called
# name: name of route 
#  path: path to call 
#  controller: Controller class 
#  action: method to be called from Controller class

info:
  path: /phpInfo
  controller: App\Controller\NewPhpRouteImp
  action: phpInfo
```
And here is how it looks like in the Controller class:
```php
<?php

namespace App\Controller;

use App\Core\BaseController;
use App\Core\Response;

class NewPhpRouteImp extends BaseController
{
    public function minusNa2Chisla($param1, $param2): Response
    {

        return $this->json([
            'Param1' => $param1,
            'param2' => $param2,
            "result" => $param1 - $param2
        ]);
    }
    public function phpInfo(): Response
    {
        return new Response(
            phpinfo()
        );
    }
};

```


## Controllers
All controllers should be placed in the **/controller** directory. Each controller class should extend the **BaseController** class to gain access to the framework’s core functionality. Each controller method should return **Response** object.

### Defining a Controller Method
To create a route in a controller, annotate the method with a **#[Route(...)]** attribute. The framework will use this route to call the corresponding method when the URL matches.

Example Controller Method:

```php
<?php

namespace App\Controller;

use App\Core\BaseController;
use App\Core\Route;
use App\Core\Response;

class TestController extends BaseController
{
    #[Route('/normal/test')]
    public function testingNormalResponse()
    {
        // Example response
        return new Response('Test text');
    }
}
```
### Available Controller Methods
The **BaseController** provides several helper methods that make it easier to handle common tasks, such as returning JSON responses, rendering templates, and generating URLs.

### json(data)
Returns a JSON response. Use this to send structured data in JSON format. Returns **Response** object.
```
return $this->json(['status' => 'success', 'data' => $data]);
```

### render(view,params)
Renders a view template. This method takes the path to an HTML template and an optional array of variables to pass to the view. Returns **Response** object.
```
return $this->render('home.html');
return $this->render('home.html', ['title' => 'Home Page']);
```

### redirectToRoute(routeName,param)
Redirects to a specified route by name. Useful for navigation within the application without hardcoding URLs. Returns **Response** object.
```
return $this->redirectToRoute('param'); // it will redirect to 'param' name route which is '/normal/test' path
```

### redirect(url)
Redirects the user to a specified URL. This method is useful for external redirects or when you want full control over the URL. Returns **Response** object.
```
return $this->redirect('https://example.com');
return $this->redirect('/path');
```

### generateUrl(routeName,param)
Generates a URL for a named route. This method is particularly useful when you need to create a link to another route within the application, as it allows you to build URLs dynamically based on route names. Returns **String**.
```
$url = $this->generateUrl('user_profile', ['id' => 42]);
```


## Models
**Models (or Entities)** in this project are responsible for interacting with the database. They should be placed in the **/model** directory and must extend the **BaseModel** class to inherit the necessary database functionality.

Each model should include an **id** parameter, which serves as the primary identifier for each record.

Example Model:
```php
class User extends BaseModel
{
    private $id;
    private $name;
    private $email;

    // Getters and setters for properties...
    public function __construct($id = null, $name = '', $email = '')
    {
        $this->id = $id;
        $this->name = $name;
        $this->email = $email;
    }
}
```
In controller you can access it by this:
```php
#[Route('/normal/test')]
public function testingNormalResponse()
{
    // Example response
    $user = new User();
    $user->setName('test'); // setter
    $user->setEmail('test@gmail.com'); //setter
        
    return new Response('Test text');
}
```
### Access the Database
You can access the database by getting an instance from **DbManipulation class**. Here is an example:
```php
#[Route('/dbtest')]
public function testingNormalResponse()
{
    $db = new DbManipulation();
    // Example response
    $user = new User();
    $user->setName('test'); // setter
    $user->setEmail('test@gmail.com'); //setter
        
    return new Response('Test text');
}
```
By this class you can create, delete and update an existing model instance. You can call this methods:
### add(BaseModel $entity)
It adds an model instance to the queue for performance of insert or update element from Database.
```php
public function testUpdateUser()
    {

        $db = new Db();
        $user = new User();
        $user->query()->where(['name', '=', "NISAAN"])->first();
        $user->setName("fff");
        $db->add($user);
        $db->commit();
        return new Response("Successfuly updated an existing record");
    }

public function testInserteUser()
    {

        $db = new Db();
        $user = new User();
        $user->setName("Test");
        $user->setAge(123);
        $db->add($user);
        $db->commit();
        return new Response("Successfuly insert a new record");
    }
```
 
### delete(BaseModel $entity)
It adds an model instance to the queue for performance of delete element from Database.
```php
public function testUser()
    {

        $db = new Db();
        $user = new User();
        $user->query()->where(['name', '=', "NISAAN"])->first();
        $db->delete($user);
        $db->commit();
        return new Response("Successfuly deleted");
    }
```

### commit()
It performs all inserted into the queue actions for update/insert and delete.
```php
public function testCommitUser()
    {

        $db = new Db();
        $db->commit();
        return new Response("Successfuly commited without doing something");
    }
```
### Available Model Methods
The BaseModel provides several helper methods for interacting with the database. These methods simplify common database operations. You can access them via using the **QueryBuilder class** by calling it this way:
```php
class User;
user->query();
```
This class have several methods:
### all(): array
Retrieves all records from the associated table.
```php
$users = $user-query->all();
```

### first(): ?BaseModel
Get first finded record.
```php
$user = $user->query->first();
```
### where(array $inputs)
It performs an sql **WHERE** operation. It have three inputs in the array: **key, operation and value**. The first element is which **row** to look into the table. The allowed **operations** are: **'=', '!=', '<', '>', '<=', '>=' and 'LIKE'**. And the **value** is the looking value from the row.
```php
public function testUser()
    {

        $db = new Db();
        $user = new User();
        $user->query()->where(['name', '=', "NISAAN"])->first();
        $db->delete($user);
        $db->commit();
        return new Response("Successfuly deleted");
    }
```
### order(array ...$inputs)
It performs an sql **ORDER BY** operation. By default it is **ASC**. It have two inputs in the array: **order by and how to order (it is not mandatory)**. It can take multiple arrays. 
```php
public function testUser()
    {

        $db = new Db();
        $user = new User();
        $user->query()->where(['name', '=', "NISAAN"])->order(["name","DESC"],["age"]).first();
        $db->delete($user);
        $db->commit();
        return new Response("Successfuly deleted");
    }
```
## Views

Views are responsible for the **HTML** structure and presentation of your application. All view files should be placed in the **/view** directory, and each view should be an **.html** file containing standard HTML markup.
```
<!-- /view/example.html -->
<h1>Welcome</h1>
<p>This is a sample HTML page.</p>
```

### Passing Data to Views
You can pass data from the controller to the view using the **render()** method. Within the HTML, use **{{ parameter }}** syntax to display dynamic data provided by the controller.

Example:

Controller Method:
```php
#[Route('/greeting')]
public function showGreeting()
{
    $name = "John";
    $content = "Welcome to our website!";
    return $this->render('greeting.html', ['name' => $name, 'content' => $content]);
}
```
View File (/view/greeting.html):
```
<h1>Hello, {{ name }}!</h1>
<p>{{ content }}</p>
```
In this example, **{{ name }}** and **{{ content }}** in the view file are placeholders that will be replaced by the values passed in the **render()** method **('name' => $name and 'content' => $content)**.

### Passing an Array to a View
Suppose you have a controller method where you want to pass an associative array to a view:
```php
#[Route('/user/profile')]
public function showUserProfile()
{
    // Define an associative array with user data
    $user = [
        'id' => 1,
        'name' => 'John Doe',
        'email' => 'john@example.com'
    ];

    // Render the view and pass the array as a parameter
    return $this->render('profile.html', ['user' => $user]);
}
```
Now, in the view, you can access the properties of the user array by referencing **{{ user.key }}** for each key in the array:
```html
<h1>User Profile</h1>
<p>User ID: {{ user.id }}</p>
<p>Name: {{ user.name }}</p>
<p>Email: {{ user.email }}</p>
```