# Custom MVC

The project **Custom MVC** is PHP open-source web application MVC framework.  

## Table of Content

- [Installation and requirements](#installation-and-requirements)
- [Project structure](#project-structure)
- [Configuration and Setup](#configuration-and-setup)
- [CLI Helper Tool](#cli-helper-tool)
  - [How to Run](#how-to-run)
  - [Commands](#commands)
- [Routes](#routes)
  - [Defining Routes with Attributes (PHP 8+)](#defining-routes-with-attributes-php-8)
  - [Defining Routes with Config Files (For Older PHP Versions)](#defining-routes-with-config-files-for-older-php-versions)
- [Controllers](#controllers)
  - [Defining a Controller Method](#defining-a-controller-method)
  - [Available Controller Methods](#available-controller-methods)
    - [json(array $data): Response](#jsonarray-data-response)
    - [render(string $view, array $params): Response](#renderstring-view-array-params-response)
    - [redirectToRoute(string $routeName, array $param): Response](#redirecttoroutestring-routename-array-param-response)
    - [redirect(string $url): Response](#redirectstring-url-response)
    - [generateUrl(string $routeName, array $param): string](#generateurlstring-routename-array-param-string)
- [Models](#models)
  - [Functionality](#functionality)
  - [Working with the Database](#working-with-the-database)
  - [Automatic Database Setup](#automatic-database-setup)
  - [Example Model Class](#example-model-class)
  - [Available Model Methods - QueryBuilder](#available-model-methods---querybuilder-class)
    - [all(): array](#all-array)
    - [first(): ?BaseModel](#first-basemodel)
    - [where(array $inputs)](#wherearray-inputs)
    - [order(array ...$inputs)](#orderarray-inputs)
  - [Access the Database](#access-the-database)
    - [add(BaseModel $entity)](#addbasemodel-entity)
    - [delete(BaseModel $entity)](#deletebasemodel-entity)
    - [commit()](#commit)
- [Views](#views)
  - [Passing Data to Views](#passing-data-to-views)
  - [Passing an Array to a View](#passing-an-array-to-a-view)
- [Tests](#tests)
  - [Running all tests](#running-all-tests)
  - [Running a Specific Test File](#running-a-specific-test-file)
## Installation and requirements

Clone the repository from GitHub or download it as a ZIP file:
     ```
     git clone https://github.com/ManoelViktorovManev/Custom_MVC.git
     ```
   - If you downloaded the ZIP file, extract it to your desired directory.


This project requires **PHP 8** or above to run. Ensure that PHP is installed and accessible from the command line.

Make sure you are having database management system (DBMS) like  **MySQL, MariaDB, PostgreSQL** or others.


## Project structure

```
project-root/
├── config/              # Configurate routes files
│   └── routes.php
│   └── routes.yaml
│
├── controller/          # Directory for user-defined Controllers, each extending the BaseController
│   └── ExampleController.php
│
├── core/                # Core framework logic and base classes (e.g., BaseController, Router, BaseModel)
│   └── BaseController.php
│   └── Router.php
│   └── BaseModel.php
│
├── model/              # Directory for user-defined models (entities), each extending BaseModel
│   └── User.php
│
├── tests/               # Directory for unit and integration tests
│   └── ExampleTest.php
│
├── vendor/              # Composer dependencies (auto-generated by Composer, do not edit manually)
│
├── view/                # Directory for HTML view templates
│   └── layout.html
│   └── home.html
│
├── .env                 # Environment variables (e.g., database URL, timezone)
├── phpunit.xml          # PHPUnit configuration file for running tests
├── composer.json        # Composer configuration file listing dependencies and autoloading settings
└── README.md            # Project documentation
```
### Configuration and Setup

1. **Edit the Configuration File**: Open the `.env` file in the project’s root directory and configure the following values:
   - **`DATABASE_URL`**: Defines the database connection string.

Example **.env** file:
```.env
DATABASE_URL="scheme://user:pass@host:port/dbName"
``` 
2. **Start the Database**: Ensure your database application is running and accessible based on the DATABASE_URL configuration.

3. **Run the Server**: In the terminal, navigate to your **project directory** and start the PHP server:
```
php -S localhost:8080
```
Your application should now be accessible at http://localhost:8080.

## CLI Helper Tool
This CLI tool provides a quick and interactive way to scaffold essential parts of your PHP MVC project — including **environment configuration, controllers, and models**.
### How to Run
Run the tool from your project’s root directory using:
```
php ./cli.php
```
You’ll be greeted with the following interactive menu:
```
php ./cli.php
Mini CLI Tool

Choose an option:
1. Edit .env file
2. Create a new Controller file
3. Create a new Model file
4. Exit
Choice:
```
### Commands
1. **Edit.env file** - Allows you to create or modify your project's .env file. For each variable:

* Enter the key name (e.g., DB_HOST)
* Enter its value (e.g., localhost)
* Type EXIT to return to the main menu

2. **Create a new Controller file** - Generates a basic controller class inside the **controller/** directory. You will:
* Be prompted for a controller name
* Automatically generate a namespaced PHP class that extends BaseController

3. **Creates a new Model file** - Generates a model class in the **model/** directory. You'll be asked:

* Model name
* Property names and types
* Whether each property is nullable

  **The tool then auto-generates:**
* PHP class with properties
* A constructor
* Getters and setters

4. **Exit** - Simply terminates the CLI tool.


## Routes
**Routes** can be defined differently depending on your **PHP** version. If you're using **PHP 8 or later**, you can define routes using **Attributes.** For older versions, you can define routes using configuration files.

### Defining Routes with Attributes (PHP 8+)
In PHP 8 and above, you can use **attributes** to define routes directly on controller methods. Each route attribute maps a specific URL pattern to a controller action, enabling clean and declarative routing.

There are four common route definitions:
```php
#[Route('/path')]                         // Basic route with a fixed path.
#[Route('/user/{id}')]                    // Route with a dynamic parameter, e.g., /user/123.
#[Route('/normal/test', name: 'param')]   // Named route, useful for generating URLs programmatically.
#[Route('/optional/{id?}')]               // Optional parameter, e.g., /optional/ or /optional/123.
```
Example:
```php
<?php

namespace App\Controller;

use App\Core\BaseController;
use App\Core\Route;
use App\Core\Response;

class NewController extends BaseController
{
    #[Route('/normal')]
    public function testingNormalRoute()
    {
        // Example response
        return new Response('Test Normal Route');
    }

    #[Route('/test/{id}')]
    public function testingDynamicParameterRoute($id)
    {
        // Example response
        return new Response('Test with number ' . $id);
    }

    #[Route('/normal/test', name: 'param')]
    public function testingNamedRoute()
    {
        // Example response
        return new Response('Test text with Named Route');
    }

    #[Route('/optional/{id?}')]
    public function testingOptionalParameterRoute($id)
    {
        // Example response
        return new Response('Test with optional ' . $id);
    }
}

```
### Defining Routes with Config Files (For Older PHP Versions)
For PHP versions prior to **8**, routes can be defined in the **config** directory using either **routes.php or routes.yaml.** These files specify paths and their corresponding controllers and actions.

Example: **routes.php**
```php
# routes.php
<?php
namespace App\Config;

use App\Core\Router;
use App\Controller\NewController;
return function (Router $routes): void {
    // Syntax: $routes->add(route_name, path)->controller(ControllerClass::class, 'methodName');
    $routes->add('izwajdane12', '/minus/{param1}/{param2}')
        ->controller(NewController::class, 'minusNa2Chisla');
};
```
Example: **routes.yaml**
```yaml
# routes.yaml

# Format:
# route_name:
#   path: /your-path
#   controller: FullyQualified\ControllerName
#   action: methodName

info:
  path: /phpInfo
  controller: App\Controller\NewController
  action: phpInfo
```
Corresponding Controller:
```php
<?php

namespace App\Controller;

use App\Core\BaseController;
use App\Core\Response;

class NewController extends BaseController
{
    public function minusNa2Chisla($param1, $param2): Response
    {
        return $this->json([
            'param1' => $param1,
            'param2' => $param2,
            'result' => $param1 - $param2
        ]);
    }

    public function phpInfo(): Response
    {
        return new Response(phpinfo());
    }
}

```
## Controllers
All controllers should be placed in the **/controller** directory. Each controller class should extend the **BaseController** class to gain access to the framework’s core functionality. Each controller method should return **Response** object.

### Defining a Controller Method
To create a route in a controller, annotate the method with a **#[Route(...)]** attribute. The framework will use this route to call the corresponding method when the URL matches.

Example Controller Method:

```php
<?php

namespace App\Controller;

use App\Core\BaseController;
use App\Core\Route;
use App\Core\Response;

class TestController extends BaseController
{
    #[Route('/normal/test')]
    public function testingNormalResponse()
    {
        // Example response
        return new Response('Test text');
    }
}
```
### Available Controller Methods
The **BaseController** provides several helper methods that make it easier to handle common tasks, such as returning JSON responses, rendering templates, and generating URLs.

### json(array $data): Response
Returns a JSON response. Use this to send structured data in JSON format. Returns **Response** object.
```php
#[Route('/jsonTest')]
public function testingJsonResponse()
{
   // Example response
   return $this->json(['status' => 'success', 'data' => $data]);
}
```

### render(string $view, array $params): Response
Renders a view template. This method takes the path to an HTML template and an optional array of variables to pass to the view. Returns **Response** object.

```php
#[Route('/renderTest')]
public function testingRenderResponse()
{
   // Example response
   return $this->render('home.html');
}

#[Route('/renderTest1')]
public function testingRenderResponse1()
{
   // Example response
   return $this->render('home.html', ['title' => 'Home Page']);
}
```

### redirectToRoute(string $routeName, array $param): Response
Redirects to a specified route by name. Useful for navigation within the application without hardcoding URLs. Returns **Response** object.
```php
#[Route('/redirectToRouteTest')]
public function testingRedirectToRouteResponse()
{
   // Example response
   return $this->redirectToRoute('param'); // it will redirect to 'param' name route which is '/normal/test' path
}

```

### redirect(string $url): Response
Redirects the user to a specified URL. This method is useful for external redirects or when you want full control over the URL. Returns **Response** object.
```php
#[Route('/redirectTest')]
public function testingRedirectResponse()
{
   // Example response
   return $this->redirect('https://example.com');
}

#[Route('/redirectTest1')]
public function testingRedirectResponse1()
{
   // Example response
   return $this->redirect('/path');
}
```

### generateUrl(string $routeName, array $param): string
Generates a URL for a named route. This method is particularly useful when you need to create a link to another route within the application, as it allows you to build URLs dynamically based on route names. Returns **String**.
```php
#[Route('/generateUrlTest')]
public function testingGenerateUrlResponse()
{
   // Example response
   $url = $this->generateUrl('user_profile', ['id' => 42]);
   return $this->redirect($url);
}
```
## Models

**Models** (also referred to as **Entities**) in this project are responsible for defining the structure of your data and handling interactions with the database. Each model corresponds to a database table and should be placed in the `/model` directory.

All models **must extend the `BaseModel` class**, which provides built-in methods for common database operations. This inheritance ensures a consistent and efficient way to interact with the database throughout the project.

---

### Functionality

By extending `BaseModel`, each model gains access to the powerful `query()` method, which provides a fluent interface for database queries. Common query methods include:

- `all(): array` – Retrieve all records
- `first(): ?BaseModel` – Fetch the first matching result
- `where(array $inputs): QueryBuilder` – Add filtering conditions
- `order(array $inputs): QueryBuilder` – Sort query results

These allow you to build expressive and readable database queries directly from your model classes.

---

### Working with the Database

You can also interact with the database directly from controllers using the `DbManipulation` class. This class provides methods for:

- Inserting new records
- Updating existing data
- Deleting records

This enables flexible database manipulation wherever needed within your application logic.

---

### Automatic Database Setup

No manual database setup is required. The system will automatically generate the database and corresponding tables based on:

- The `DATABASE_URL` value set in your `.env` file
- The structure of your model classes in the `/model` directory

This means you can focus on defining your models and let the framework handle the rest.

### Example Model class:
It will be good if you defined **getters and setters** to every Model class.
```php
<?php

namespace App\Model;

use App\Core\BaseModel;

class User extends BaseModel
{
    private ?int $id;
    private string $name;
    private string $email;

    // Getters and setters for properties...
    public function __construct($id = null, $name = '', $email = '')
    {
        $this->id = $id;
        $this->name = $name;
        $this->email = $email;
    }
     public function getId(): int
    {
        return $this->id;
    }

    public function setId(int $id): void
    {
        $this->id = $id;
    }

    public function getName(): string
    {
        return $this->name;
    }

    public function setName(string $name): void
    {
        $this->name = $name;
    }

    public function getEmail(): string
    {
        return $this->email;
    }

    public function setEmail(string $email): void
    {
        $this->email = $email;
    }
}
```

In controller you can access it by this:
```php
#[Route('/accessUser')]
public function accessEntity()
{
    $user = new User();       
    return new Response("Access entity");
}
```
### Available Model Methods - QueryBuilder class
The BaseModel provides several helper methods for interacting with the database. These methods simplify common database operations. You can access them via using the **QueryBuilder class** by calling it this way:
```php
#[Route('/accessUserQuery')]
public function accessEntityQuery()
{
    $user = new User();
    $user_query = $user->query();
    return new Response("Access entity query");
}
```
This class have several methods:
### all(): array
Retrieves all records from the associated table.
```php
#[Route('/accessAllUsers')]
public function accessAllUsers()
{
    $user = new User();
    $all_users = $user->query()->all();
    print_r($all_users);
    return new Response("Access all users ");
}
```

### first(): ?BaseModel
Get first finded record.
```php
#[Route('/accessfirstUser')]
public function accessfirstUser()
{
    $user = new User();
    $user->query()->first();
    return $this->json([$user->getId(), $user->getName(), $user->getEmail()]);
}
```
### where(array $inputs)
It performs an sql **WHERE** operation. It have three inputs in the array: **key, operation and value**. The first element is which **row** to look into the table. The allowed **operations** are: **'=', '!=', '<', '>', '<=', '>=' and 'LIKE'**. And the **value** is the looking value from the row.
```php
#[Route('/accessWhereUser')]
public function accessWhereUser()
{
    $user = new User();
    $user->query()->where(['name', '=', "TEST"])->first();

    return $this->json([$user->getId(), $user->getName(), $user->getEmail()]);
}
```
### order(array ...$inputs)
It performs an sql **ORDER BY** operation. By default it is **ASC**. It have two inputs in the array: **order by and how to order (it is not mandatory)**. It can take multiple arrays. 
```php
#[Route('/accessOrderUser')]
public function accessOrderUser()
{
    $users = new User();
    $all_users = $users->query()->order(["name"])->first();
    print_r($all_users);
    return new Response("Successfuly order");
}
```
### Access the Database
You can access the database by getting an instance from **DbManipulation class**. Here is an example:
```php
#[Route('/accessDB')]
public function accessDB()
{
    $db = new DbManipulation();
    return new Response('Test DB access');
}
```
By this class you can create, delete and update an existing model instance. You can call this methods:
### add(BaseModel $entity)
It adds an model instance to the queue for performance of insert or update element from Database.
```php
#[Route('/updateDB')]
public function testUpdateUser()
{
    $db = new DbManipulation();
    $user = new User();
    $user->query()->where(['name', '=', "NISAAN"])->first();
    $user->setName("fff");
    $db->add($user);
    $db->commit();
    return new Response("Successfuly updated an existing record");
}

#[Route('/insertDB')]
public function testInserteUser()
{
    $db = new DbManipulation();
    $user = new User(null, "NISAAN", "test@gmail.com");
    $db->add($user);
    $db->commit();
    return new Response("Successfuly insert a new record");
}
```
 
### delete(BaseModel $entity)
It adds an model instance to the queue for performance of delete element from Database.
```php
#[Route('/deleteDB')]
public function testDeleteUser()
{
    $db = new DbManipulation();
    $user = new User();
    $user->query()->where(['name', '=', "fff"])->first();
    $db->delete($user);
    $db->commit();
    return new Response("Successfuly deleted");
}
```

### commit()
It performs all inserted into the queue actions for **update/insert and delete.**
```php
#[Route('/commitDB')]
public function testCommitUser()
{
    $db = new DbManipulation();
    $db->commit();
    return new Response("Successfuly commited without doing something");
}
```
## Views

Views are responsible for the **HTML** structure and presentation of your application. All view files should be placed in the **/view** directory, and each view should be an **.html** file containing standard HTML markup.
```
<!-- /view/example.html -->
<h1>Welcome</h1>
<p>This is a sample HTML page.</p>
```

### Passing Data to Views
You can pass data from the controller to the view using the **render()** method. Within the HTML, use **{{ parameter }}** syntax to display dynamic data provided by the controller.

Example:

Controller Method:
```php
#[Route('/greeting')]
public function showGreeting()
{
    $name = "John";
    $content = "Welcome to our website!";
    return $this->render('greeting.html', ['name' => $name, 'content' => $content]);
}
```
View File (/view/greeting.html):
```
<h1>Hello, {{ name }}!</h1>
<p>{{ content }}</p>
```
In this example, **{{ name }}** and **{{ content }}** in the view file are placeholders that will be replaced by the values passed in the **render()** method **('name' => $name and 'content' => $content)**.

### Passing an Array to a View
Suppose you have a controller method where you want to pass an associative array to a view:
```php
#[Route('/user/profile')]
public function showUserProfile()
{
    // Define an associative array with user data
    $user = [
        'id' => 1,
        'name' => 'John Doe',
        'email' => 'john@example.com'
    ];

    // Render the view and pass the array as a parameter
    return $this->render('profile.html', ['user' => $user]);
}
```
Now, in the view, you can access the properties of the user array by referencing **{{ user.key }}** for each key in the array:
```html
<h1>User Profile</h1>
<p>User ID: {{ user.id }}</p>
<p>Name: {{ user.name }}</p>
<p>Email: {{ user.email }}</p>
```
## Tests
In this MVC we have build in tests, which it can be find inside **/tests** folder. 

### Running All Tests
To run all tests, navigate to your project root in the terminal and execute:
```
vendor/bin/phpunit 
```
This command will automatically discover and run all test files in the **/tests** directory based on the configuration defined in **phpunit.xml.**

### Running a Specific Test File
To run a specific test file (e.g., a custom test), use the following command:
```
vendor/bin/phpunit path/to/YourTestFile.php
```
Example:
```
vendor/bin/phpunit ./tests/CustomPHPTest.php
```